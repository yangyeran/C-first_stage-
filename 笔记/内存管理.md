@[toc](目录)

## 内存管理

<img src="C:/Users/yangyr0206/AppData/Roaming/Typora/typora-user-images/image-20220407155236122.png" alt="image-20220407155236122" style="zoom: 80%;" />

**注意：**

1. 栈又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的。

2. 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。

3. 堆用于程序运行时动态内存分配，堆是可以上增长的。

4. 数据段--存储全局数据和静态数据。

5. 代码段--可执行的代码/只读常量。  

---

### C++内存管理方式

* 先回顾一下C语言中动态内存管理方式：**malloc/calloc/realloc和free**

  * calloc和malloc的区别

    calloc会初始化，相当于，malloc+memset，按字节初始化，空间每个字节都初始化为0

  * realloc扩容：可能原地扩容可能异地扩容

C语言内存管理方式在C++中可以继续使用，但是有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：**通过new和delete操作符进行动态内存管理**

#### new和delete

**用法：**

1. **对于内置类型**

```c++
//动态申请int和4个int数组
//new 后面跟类型
int *p1=new int;
int *p2=new int[4]//申请了4个int
int *p3=(int*)malloc(sizeof(int));
int *p4=(int*)malloc(sizeof(int)*4);
delete p1;//释放单个
delete[] p2;//释放数组
free(p3);
free(p4);
p1=nullptr;p2=nullptr;p3=nullptr;p4=nullptr;
// malloc/free 和 new/delete对于内置类型没有本质区别，new和delete看起来会比较简洁
```

```c++
//p1:动态申请一个int空间，这块空间初始化为4
int *p1=new int(4);
//p2:动态申请4个int的空间
//C++98不支持初始化new的数组，C++11支持{}列表初始化
//int *p2=new int[4]{1,2,3,4};
int *p2=new int[4];
```

2. **对于自定义类型**

   ```c++
   class A
   {
    public:
       A(int a=0)
           :_a(a)
           { cout<<"A()"<<endl;}
       ~A()
       {cout<<"~A()"<<endl;}
    private:
       int _a;
   };
   //首先对于自定义类型，以下两种方式都可以
   //1.malloc开辟自定义类型只能开辟空间
   A* p1=(A*)malloc(sizeof(A));
   A* p2=(A*)malloc(sizeof(A)*4);
   //2.new对于自定义类型，不仅能开辟空间，还会去自动调用自定义类型的构造函数
   A* p3= new A;
   A* p4= new A[4];
   free(p1);
   free(p2);
   //delete是先调用指针类型的析构函数+释放空间给堆
   delete p3;
   delete[] p4;
   //一定malloc free和new  delete和new[] delete[] 要匹配使用，否则可能会出问题
   ```

**第一个原因就是new和delete会自动调用自定义类型的构造和析构函数**

---

**使用new和delete的第二个原因**

* 面向对象的语言，处理错误的方式一般是抛异常，C++中也要求出错抛异常--->try catch

  ```c++
  void BuyMemory()
  {
      //如果没有异常就会往下执行
      //如果出现问题会直接跳到catch抛异常
      char* p=new char[100];
      printf("%p\n,p2");
  }
  try
  {
      BuyMemory();
  }
  catch (const exception& e)
  {
      cout<<e.what()<<endl;
  }
  ```

* 面向过程的语言，处理错误的方式是--->返回值+错误码解决

**总结**

C++提出new和delete，主要是解决两个问题

1. 自定义类型对象自动申请的时候，初始化和清理的问题。new/delete会调用构造函数和析构函数
2. new失败了以后要求抛异常，这样才符合面向对象语言的出错处理机制(delete和free一般不会失败，如果失败了，都是释放空间上存在越界或者释放指针位置不对)

