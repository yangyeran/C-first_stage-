@[TOC](目录)

# 类和对象(中)

#### 一.类的6个默认成员函数

* 初始化和清理
  * 析构函数:主要完成清理
  * 构造函数:主要完成初始化
* 拷贝复制
  * 拷贝构造是使用同类对象初始化创建对象
  * 赋值重载主要是吧一个对象赋值给另一个对象
* 取地址重载:主要是普通对象和const对象取地址

##### 1.构造函数

**特性**

构造函数是特殊的成员函数，需要注意，虽然构造函数名叫构造，但是**主要任务并不是开空间创建对象，而是初始化对象**

**特征**

1. 函数名与类名相同

2. 无返回值

3. 对象实例化时编译自动调用对应的构造函数

4. 构造函数可以重载

5. 如果类中没有显示定义构造函数,C++编译器会自动生成一个构造函数,如果定义了编译器就不会自动生成
   * C++中把类型分为两类:*内置类型,自定义类型*,**C++自动生成的构造函数不会初始化内置类型,对于自定义类型会去调用自定义类型的默认构造函数（不用参数可以调用）初始化**，如果没有默认构造函数**就会报错**。
   
   * **默认构造函数**-->不用参数就可调用-->有三个：**全缺省，无参的，编译器自动生成的**
   
   * 不能以显示调用的方式来调用构造函数
   
     ```c++
     class A{
     public:
         A()
         {
             cout<<A()<<endl;
             _a=0;
         }
     private:
         int _a;
     }
     int main()
     {
         A a;//这时候就已经调用构造函数了
         //a.A();这会报错
     }
     ```

---

##### 2.析构函数

**概念：**

与构造功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器来完成的。而**对象在销毁时会自动调用析构函数，完成对象中的一些资源清理工作**

**特性：**

1. 无参数无返回值
2. 析构函数名是在类名前面加上**~**
3. 一个类有且仅有一个析构函数，若未显示定义，系统会自动生成
   * 默认生成的析构函数和构造函数类似
   * 对于内置类型成员变量不处理
   * 对于自定义类型会去调用它的析构函数

4. 对象生命周期结束时，C++编译系统自动调用析构函数

---

##### 3.拷贝构造

**概念：**

**只有单个形参**，该形参是对本类类型对象的**引用**(**一般常用const修饰**)，在用**已存在的类类型对象创建新对象时由编译器自动调用**

**特征：**

1. **是构造函数的一个重载形式**

2. 参数只有一个且**必须使用引用传参** **（使用传值传参会引发无穷递归调用）**

   * ```c++
     Date (const Data data)
     {
         _year=year;
         _month=month;
         _day=day;
     }
     //当你Date d2(d1);
     //调用拷贝构造需要先传参数，传值传参又是一个拷贝构造，所以会无穷递归
     Date (const Data& data)
     {
         //....
     }
     //Data d2(&d1)当用引用时就不会发生拷贝构造，里面的data就是d1，没有传值传参那就不会再发生拷贝构造
     ```

3. 若未显示定义，系统会默认生成一个拷贝构造函数

   **默认生成的拷贝构造：**

   * 内置类型成员，会完成按字节序的拷贝(**浅拷贝**)

     ```c++
     //对于栈这种类，这种浅拷贝是不行的
     Stack{
         //....
         //栈是需要malloc开辟空间的
     }
     //调用这个栈默认的拷贝构造，会导致st1和st2指向同一块malloc开辟的空间
     //首先st1和st2出了作用域的时候会自动调用析构函数，会让指向的空间释放两次，导致程序崩溃
     //其次当更改st1或者st2时另外一方也会跟着被改动
     int main()
     {
         //所以需要深拷贝(要自己实现)
         Stack st1(10);
         Stack st2(st1);
     }
     ```

   * 自定义类型成员，会调用它的拷贝构造

**例题：**

```c++
//调用了几次拷贝构造
Widget f(Widget u)
{
    //返回进行拷贝构造
    return u;
}
 int main()
 {
     Widget x;
     //传值需要进行拷贝构造
     //拿返回的值拷贝构造 y
     Widget y=f(x);
     //widget(); 这个是匿名对象，生命周期只在这一行
     f(widger());//会优化成一次拷贝构造
     return 0;
     //按照正常情况下是调用3次拷贝构造
     //但是编译器做了优化
     //一次调用里面，连续构造函数，会被编译器优化，合二为一(C++标准没有规定要做这个优化，是否有这个优化需要看具体的编译器，大部分都做了)
     //所以这里是2次拷贝构造
 }
```

```c++
//接着看这个代码
//拷贝构造多少次
//优化的时机：传参或者传返回值过程中，存在连续的构造、拷贝构造，就会被优化
Widget f(Widget u)
{
    Widget v(u);
    Widget w=v;
    return w;
}
int main()
{
    Widget x;
    Widget y=f(f(x));
}
//答案：7次
```



---

##### 4.运算符重载

**概念：**

**C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数**，也具有返回值类型

函数名为：关键字**operator后面接需要重载的运算符符号**

函数原型：**返回值类型operator操作符(参数列表)**

```c++
bool operator>(/*日期类为例*/const Date& d1,const Date& d2);
```

**注意：**

* 不能通过链接其它运算符来创建新的运算符：比如operator@
* 重载操作符必须有一个类类型参数(就是说**必须是自定义类型才能进行运算符重载**)
* 用于内置类型的运算符，其含义不能改变(例如：内置的+，不能改变其含义，也就是不能把它实现成-)
* 作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参
* **.***、**::**、**sizeof**、**?:**、**.**注意以上五个运算符不能重载(**这个很重要**)

##### 5.赋值重载

**赋值运算符重载主要有以下几点：**

1. 参数类型
2. 返回值
3. 检测是否自己给自己赋值
4. 返回*this
5. 一个类如果没有显示定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝(浅拷贝)

**注意：**

**赋值重载是两个已经存在的对象之间进行赋值拷贝；拷贝构造是一个已经存在的对象拷贝初始化一个马上创建实例化的对象**

**总结：**

**默认生成的这四个默认成员函数，构造和析构处理机制是基本类似的；拷贝构造和赋值重载处理机制是基本类似的**

##### 6.const成员函数

```c++
//这是一个输出函数
void Date::Print()//这里的this是--->Date* const this ----> const是保护this不会改变
{
    cout<<_year<<"-"<<_month<<"-"<<_day<<endl;
}
int main()
{
    Date d1;//1
    //这里传的是：Date*
    d1.Print();//&d1
    
    const Date d2;//2
    //这里传的是：const Date* const this
    //将这个传给Print把权限放大了
    d2.Print();
    return 0;
    //这两个有什么区别呢？
    //首先1能编过，而2会报错
    //原因就是2涉及到了权限的放大，我们都知道成员函数会默认传入一个this指针
    //c++提供的方法就是在函数后面加上const：void Date::Print() const
}
```

**总结：**

成员函数加const是好的，建议是能加const都加上。这样普通对象和const对象都可以调用了;如果要修改成员变量的成员函数是不能加的

---

##### 7.取地址及const取地址操作符重载

**这两个默认成员函数意义不是很大，编译器默认生成的就已经够用了，当然也可以自己重载**

```c++
Date* operator&()  //普通版本
{
    return this;
}
const Date* operartor&() const
{
    //const版本
    return this;
}
```

